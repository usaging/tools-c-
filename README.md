# 介绍

# procctl

服务程序的调度程序，周期性启动服务程序或shell脚本。

Using:./procctl timetvl program argv ...

fork子进程执行任务，父进程等待子进程退出，然后sleep一段时间，再次fork。

# checkproc

检查后台服务程序是否超时，如果已超时，就终止它。

Using:./checkproc logfilename

遍历共享内存中全部的进程记录，如果进程已超时，终止它。

# gzipfiles

这是一个工具程序，用于压缩历史的数据文件或日志文件。

Using:./gzipfiles pathname matchstr timeout

本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部压缩，timeout可以是小数。

# deletefiles

这是一个工具程序，用于删除历史的数据文件或日志文件。

Using:./deletefiles pathname matchstr timeout

本程序把pathname目录及子目录中timeout天之前的匹配matchstr文件全部删除，timeout可以是小数。

# ftpputfiles

用于将本地文件上传到FTP服务器。

## 关键组件

1. 参数结构体 (st_arg)

- 远程服务端的IP和端口
- 传输模式，1-被动模式，2-主动模式
- 远程服务端ftp的用户名
- 远程服务端ftp的密码
- 远程服务端存放文件的目录
- 本地文件存放的目录
- 待上传文件匹配的规则
- 上传后客户端文件的处理方式
- 上传后客户端文件的备份目录
- 已上传成功文件名清单
- 进程心跳的超时时间
- 进程名

2. 核心容器
map<string, string> mfromok: 存放已上传成功文件的信息

list<struct st_fileinfo> vfromdir: 本地目录中的文件列表

list<struct st_fileinfo> vtook: 本次不需要上传的文件

list<struct st_fileinfo> vupload: 本次需要上传的文件

3. 核心函数

loadlocalfile(): 加载本地文件列表

loadokfile(): 加载已上传成功文件信息

compmap(): 比较文件列表，确定需要上传的文件

writetookfile(): 写入已上传文件信息

appendtookfile(): 追加上传成功的文件记录

## 核心工作流程

1. FTP连接和认证
   
2. 获取本地文件列表

3. 增量上传处理（ptype=1）

加载已上传文件信息到容器mfromok。

比较文件列表，确定需要上传的文件。

更新已上传文件信息。

4. 文件上传

遍历需要上传的文件列表。

拼接本地和远程文件路径。

使用ftp.put()方法上传文件。

处理上传后的本地文件（根据ptype参数）。

5. 文件处理

ptype=1: 记录已上传文件信息。

ptype=2: 删除本地文件。

ptype=3: 将本地文件移动到备份目录。

# ftpgetfiles.cpp

用于从FTP服务器下载文件到本地目录。

## 关键组件

1. 参数结构体 (st_arg)

- 远程服务端的IP和端口
- 传输模式，1-被动模式，2-主动模式
- 远程服务端ftp的用户名
- 远程服务端ftp的密码
- 远程服务端存放文件的目录
- 本地文件存放的目录
- 待下载文件匹配的规则
- 下载后服务端文件的处理方式
- 下载后服务端文件的备份目录
- 已下载成功文件信息存放的文件
- 是否需要检查服务端文件的时间
- 进程心跳超时的时间
- 进程名

这个结构体定义了FTP文件下载的所有配置参数。

2. 核心容器

map<string, string> mfromok: 存放已下载成功文件的信息。

list<struct st_fileinfo> vfromnlist: 下载前列出服务端文件名的容器。

list<struct st_fileinfo> vtook: 本次不需要下载的文件的容器。

list<struct st_fileinfo> vdownload: 本次需要下载的文件的容器。

3. 核心函数
   
loadokfile(): 加载已下载成功文件信息。

loadlistfile(): 加载FTP服务器文件列表。

compmap(): 比较文件列表，确定需要下载的文件。

writetookfile(): 写入已下载文件信息。

appendtookfile(): 追加下载成功的文件记录。

## 核心工作流程

1. 初始化阶段

2. FTP连接和认证

登录FTP服务器

切换到远程目录

3. 获取文件列表

使用ftp.nlist()方法获取服务器文件列表

将文件列表保存到本地临时文件

加载文件列表到容器vfromnlist

4. 增量下载处理（ptype=1）

加载已下载文件信息到容器mfromok

比较文件列表，确定需要下载的文件

更新已下载文件信息

5. 文件下载

遍历需要下载的文件列表

拼接远程和本地文件路径

使用ftp.get()方法下载文件

处理下载后的文件（根据ptype参数）

6. 文件处理

ptype=1: 记录已下载文件信息

ptype=2: 删除服务器上的文件

ptype=3: 将服务器文件移动到备份目录

# tcpgetfiles.cpp，采用tcp协议，实现文件下载的客户端。

## 核心工作流程

- 初始化：解析参数、连接服务器、登录认证。
- 循环等待：
阻塞读取服务器发送的报文，设置读取超时。
判断报文类型：
心跳报文 : 回复确认，保持连接活跃。
文件下载指令 : 解析指令，接收文件内容，保存到本地，并向服务器发送下载结果确认。
- 退出：当网络读取出错或连接断开时，程序退出。

## 关键组件分析

1. 参数结构 (st_arg)

clienttype: 固定为2，表明是下载客户端。
srvpath & andchild & matchname: 定义了服务器上被下载文件的来源（这些参数主要用于服务器端筛选文件，客户端通过登录报文传递给服务器）。
clientpath: 文件下载到客户端的哪个目录。
ptype & srvpathbak: 定义了文件成功下载后，服务器端如何处理源文件（删除或备份）。这个处理是由服务器根据客户端的配置执行的。
timetvl, timeout, pname: 功能同上传客户端。

2. 协议设计与工作模式

tcpputfiles (上传): 客户端主动。客户端扫描目录 -> 主动发送文件 -> 服务器接收并回应。
tcpgetfiles (下载): 服务器主动。客户端等待 -> 服务器发送文件指令 -> 客户端接收并回应。

a.登录阶段

b.主循环 - 等待指令

客户端设置一个读取超时（略大于扫描间隔timetvl），阻塞等待服务器发送任何报文。

服务器发送的报文有两种：

心跳报文 : 由服务器定时发起，用于保活。客户端只需回复 ok。

文件下载请求报文: 当服务器扫描到有文件需要下载时，会向客户端发送一个包含文件元数据的指令。

客户端处理下载请求:

解析元数据： 报文中的 filename、mtime、size。

生成本地路径： 将服务器路径 srvpath 替换为本地路径 clientpath，得到文件将保存的本地位置。

接收文件内容： 调用 recvfile 函数，根据 size 循环读取网络数据并写入本地文件。

发送结果ACK：

服务器根据这个ACK结果决定是否执行ptype操作（删除或移动服务器上的源文件）。

c.recvfile 函数

负责接收文件数据流。

采用分块接收（1000字节）的方式，内存效率高。

使用 cofile 类写入文件，支持创建中间临时文件并在写入完成后原子性地重命名，避免了下载一半的文件被误读。

下载完成后，使用 setmtime 设置本地文件的修改时间，与服务器端文件保持一致。

# tcpputfiles.cpp，采用tcp协议，实现文件上传的客户端。

## 核心工作流程

- 初始化：解析参数、连接服务器、登录认证。
- 循环执行：
扫描本地目录，获取文件列表。
遍历文件列表，逐个上传文件。
发送文件信息（元数据）。
发送文件内容（数据）。
接收并处理服务器的确认报文。
根据确认结果和处理策略（ptype）删除或移动本地文件。
- 心跳保活：在空闲时间间隔内，与服务器保持心跳连接，确保链路通畅。

## 关键组件分析

1. 参数结构 (st_arg)
该结构体定义了程序运行的所有配置，是其灵活性的核心：

clienttype: 客户端类型（固定为1，上传）。
ip & port: 服务器地址。
clientpath & andchild & matchname: 定义从哪里、上传什么文件。（源）
srvpath: 文件上传到服务器的哪个目录。（目标）
ptype & clientpathbak: 定义文件上传成功后如何处理。（后续动作）
timetvl: 控制执行任务的频率。
timeout & pname: 用于进程心跳和监控。

2. 网络通信 (ctcpclient tcpclient)
封装了 TCP 客户端的基础操作（连接、读写）。
程序在整个生命周期内保持一个长连接，避免了频繁建立连接的开销。

3. 协议设计
程序与服务器之间设计了一个简单的应用层协议，用于协调文件传输：

a.登录阶段

客户端发送： 完整的参数 XML 缓冲区，并附加 <clienttype>1</clienttype>。
服务端回应：  一个简单的确认报文。（代码中未严格验证回应内容，这是一个潜在弱点）

b.文件传输阶段（针对每个文件）

元数据报文：
客户端发送： <filename>/path/file</filename><mtime>20231010</mtime><size>1024</size>
目的： 告知服务器即将传输的文件信息。
数据报文：
客户端发送： 将文件内容分块（每次 1000 字节）直接通过 TCP 流发送。
注意： 这里没有额外的协议头，服务器需要依靠 size 字段来判断数据何时结束。这是一种简单有效的流式传输方式。
确认 (ACK) 报文：
服务端发送： <filename>/path/file</filename><result>ok</result> (或其它错误信息)
客户端处理 (ackmessage): 根据 result 和 ptype 决定是删除文件还是移动到备份目录。

c.心跳阶段

客户端发送： <activetest>ok</activetest>
服务端回应： 任意内容（只需确认连接通畅）。

4. 文件传输机制 (sendfile 函数)

分块读取和发送： 使用固定大小（1000 字节）的缓冲区循环读取文件并发送，内存使用效率高，适用于大文件。

二进制模式： 以 ios::binary 模式打开文件，确保任何格式的文件都能被正确传输。

5. 流量控制与可靠性 (delayed 变量)

这是客户端实现简单流量控制和保证可靠性的关键机制：

delayed 计数器记录已发送但未收到确认的文件数量。
每成功发送一个文件，delayed++。
每收到一个确认报文，delayed-- 并处理对应文件。
在循环内部 (while (delayed > 0)) 和结束后都会尝试读取确认报文。

作用：
防止淹没对端： 避免客户端在未收到确认时无限制地发送文件，给服务器造成过大压力。
保证处理顺序： 确保每个文件的确认都能得到及时处理。
增强健壮性： 如果连接中断，所有已发送但未确认的文件将在下次运行时重传（因为它们仍然存在于本地目录中）。

6. 目录扫描 (cdir dir)

使用 opendir 和 readdir 遍历本地目录。
支持递归子目录 (starg.andchild)。
支持文件名匹配 (starg.matchname)。
